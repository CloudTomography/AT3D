from unittest import TestCase
from collections import OrderedDict
import warnings
import numpy as np
import xarray as xr
import at3d
import sys

warnings.filterwarnings('ignore')

import builtins as __builtin__
def print(*args, **kwargs):
    if '-vv' in sys.argv:
        return __builtin__.print(*args, **kwargs)


def parse_shdom_output(filename, comment='*'):
    """
    Parse output from original SHDOM files
    """
    output = []
    with open(filename) as file:
        data = file.readlines()
        for line in data:
            if not comment in line:
                output.append(np.fromstring(line, sep=' '))
    return np.array(output)

def get_basic_state_for_surface():
    config = at3d.configuration.get_config('../default_config.json')
    config['split_accuracy'] = 0.001
    config['spherical_harmonics_accuracy'] = 0.0
    config['num_mu_bins'] = 16
    config['num_phi_bins'] = 32
    config['solution_accuracy'] = 1e-5
    config['x_boundary_condition'] = 'periodic'
    config['y_boundary_condition'] = 'periodic'
    config['ip_flag'] = 3

    rte_grid = at3d.grid.make_grid(0.02, 50, 0.02, 1,
                               np.array([0,3.0,6.0,9.0,12.0,15.0,18.0,21.0,24.0,27.0,30.0]))

    atmosphere = xr.Dataset(
        data_vars = {
            'temperature': ('z', np.array([288.0,269.0,249.0,230.0,217.0,217.0,217.0,218.0,221.0,224.0,227.0])),
            'pressure': ('z', np.ones(rte_grid.z.size)*1013.25)
                        },
        coords = {'z': rte_grid.z.data}
    )
    wavelengths = np.atleast_1d(0.85)
    rayleigh= at3d.rayleigh.to_grid(wavelengths,atmosphere,rte_grid)
    rayleigh[0.85]['extinction'] = (['x','y','z'],np.round(rayleigh[0.85].extinction.data,4))

    x = np.linspace(0,1.0-1.0/50,50)
    y = np.zeros(50)
    z = np.ones(50)*30.0
    mu = np.array([0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]+[1.0]+[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9][::-1])
    phi = np.array([180.0]*9+[0.0]*10)

    x2 = np.tile(x,19)
    y2 = np.tile(y,19)
    z2 = np.tile(z,19)
    mu2 = np.repeat(mu,50)
    phi2 = np.repeat(phi,50)

    sensor = at3d.sensor.make_sensor_dataset(x2.ravel(),y2.ravel(),z2.ravel(),mu2.ravel(),np.deg2rad(phi2.ravel()),['I'],
                                             0.85, fill_ray_variables=True)
    return sensor, rayleigh, config


def solve_prop(solver, filename='data/rico32x36x26w672.prp'):
    """
    This function is for verification against SHDOM.
    Must be polarized. Base grid, source, numerical parameters, surface etc
    must match what is in the SHDOM namelist. TODO move to tests.
    """
    solver._prepare_optical_properties()#_init_solution(make_big_arrays=False)
    solver._interpmethod = 'OO'
    #initialize some variables that are modified by the at3d.core.read_properties routine.
    nleg = solver._ml + 1 if solver._deltam else solver._ml
    #read property information from a file generated by SHDOM's propgen program.
    nstleg, nleg, npx, npy, npz, numphase, maxleg, maxpgl, delx, dely = \
        at3d.core.read_property_size(propfile=filename,
                                        nleg=nleg,
                                        nstleg=solver._nstleg
                                        )
    #double check consistency with what is used to initialize `solver`.
    assert nstleg == solver._nstleg,'{}, {}'.format(nstleg, solver._nstleg)
    assert npx == solver._pa.npx,'{}, {}'.format(npx, solver._pa.npx)
    assert npy == solver._pa.npy,'{}, {}'.format(npy, solver._pa.npy)
    assert npz == solver._pa.npz,'{}, {}'.format(npz, solver._pa.npz)
    assert np.allclose(delx, solver._pa.delx),'{}, {}'.format(delx, solver._pa.delx)
    assert np.allclose(dely, solver._pa.dely),'{}, {}'.format(dely, solver._pa.dely)
    solver._maxpgl = maxpgl
    solver._maxleg = maxleg
    solver._pa.delx = delx
    solver._pa.dely = dely
    npx, npy, npz, maxleg, nleg, proptype, delx, dely, \
    zout, maxasym, tempp, extinctp, albedop, \
    legenp, numphase, iphasep \
     = at3d.core.read_properties(propfile=filename,
                                  maxnz=solver._maxnz,
                                  npx=solver._pa.npx,
                                  npy=solver._pa.npy,
                                  npz=solver._pa.npz,
                                  maxpg=solver._maxpg,
                                  maxpgl=solver._maxpgl,
                                  deltam=solver._deltam,
                                  nstleg=6,
                                  maxleg=maxleg,
                                  nleg=nleg
                              )
    #overwrite some things that were set during the solver._init_solution.
    #this is done to account for the differences in selected phase functions.
    solver._maxasym = maxasym
    solver._pa.nlegp = maxleg
    solver._nleg = solver._ml + 1 if solver._deltam else solver._ml
    solver._nscatangle = max(36, min(721, 2 * solver._pa.nlegp))
    solver._maxigl = maxpgl
    solver._nstphase = min(solver._nstleg, 2)
    solver._pa.tempp = tempp
    solver._pa.extinctp = extinctp
    solver._pa.numphase = numphase
    solver._pa.iphasep = iphasep[np.newaxis, ...]
    solver._pa.albedop = albedop
    solver._pa.legenp = legenp
    max_num_micro = 1
    solver._pa.phasewtp = np.ones(solver._pa.iphasep.shape)
    #overwrite the main optical properties on grid.
    solver._temp, solver._planck, solver._extinct, solver._albedo, solver._legen, solver._iphase, \
    solver._total_ext, solver._extmin, solver._scatmin, solver._albmax,ierr,errmsg, \
    solver._phaseinterpwt = at3d.core.transfer_pa_to_grid(
        interpmethod='OO',
        maxnmicro=max_num_micro,
        phasewtp=solver._pa.phasewtp,
        nlegp=solver._pa.nlegp,
        phasemax=solver._phasemax,
        nstleg=solver._nstleg,
        npart=solver._npart,
        extinctp=solver._pa.extinctp,
        albedop=solver._pa.albedop,
        iphasep=solver._pa.iphasep,
        delx=solver._pa.delx,
        dely=solver._pa.dely,
        xstart=solver._pa.xstart,
        ystart=solver._pa.ystart,
        zlevels=solver._pa.zlevels,
        tempp=solver._pa.tempp,
        legenp=solver._pa.legenp,
        nzckd=solver._pa.nzckd,
        zckd=solver._pa.zckd,
        gasabs=solver._pa.gasabs,
        ml=solver._ml,
        mm=solver._mm,
        numphase=solver._pa.numphase,
        deltam=solver._deltam,
        units=solver._units,
        waveno=solver._waveno,
        wavelen=solver.wavelength,
        gridpos=solver._gridpos,
        nleg=solver._nleg,
        maxig=solver._maxig,
        npx=solver._pa.npx,
        npy=solver._pa.npy,
        npz=solver._pa.npz,
        srctype=solver._srctype,
        npts=solver._npts)
    at3d.checks.check_errcode(ierr, errmsg)
    #finally initialize the radiance/source fields based on the optical properties.
    solver._init_solution()
    #solve without redoing init_solution which would undo all the work we did.
    solver.solve(maxiter=100, init_solution=False, verbose=False)


class Verify_Solver(TestCase):
    @classmethod
    def setUpClass(cls):
        #shdom_polarized = xr.open_dataset('data/shdomout_rico32x36x26w672_polarized.nc')

        cloud_scatterer = at3d.util.load_2parameter_lwc_file('data/rico32x36x26.txt',
                                                   density='lwc')

        rte_grid = at3d.grid.make_grid(cloud_scatterer.x.data[1] -cloud_scatterer.x.data[0],cloud_scatterer.x.data.size,
                                   cloud_scatterer.y.data[1] -cloud_scatterer.y.data[0],cloud_scatterer.y.data.size,
                                   np.append(np.array([0.0]),cloud_scatterer.z.data))

        #resample the cloud onto the rte_grid
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, cloud_scatterer)

        #define any necessary variables for microphysics here.
        size_distribution_function = at3d.size_distribution.gamma
        #We choose a gamma size distribution and therefore need to define a 'veff' variable.
        cloud_scatterer_on_rte_grid['alpha'] = (cloud_scatterer_on_rte_grid.reff.dims,
                                               np.full_like(cloud_scatterer_on_rte_grid.reff.data, fill_value=7))

        wavelengths = np.atleast_1d(0.672)
        x,y = np.meshgrid(np.arange(0.0,0.62,0.0133), np.arange(0.0,0.70,0.0133))

        x=x.ravel()
        y=y.ravel()

        mu = np.array([1.0,0.5,0.2,0.5,0.2])
        phi = np.array([0.0,0.0,0.0,90.0,90.0])
        z = np.ones(x.size)*1.0
        x2 = np.tile(x,5)
        y2 = np.tile(y,5)
        z2 = np.tile(z,5)
        mu2 = np.repeat(mu,x.size)
        phi2 = np.repeat(phi,x.size)

        sensor = at3d.sensor.make_sensor_dataset(x2.ravel(),y2.ravel(),z2.ravel(),mu2.ravel(),np.deg2rad(phi2.ravel()),['I'],
                                                 0.672, fill_ray_variables=True)
        Sensordict = at3d.containers.SensorsDict()
        Sensordict.add_sensor('Sensor0', sensor)

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.1
        config['spherical_harmonics_accuracy'] = 0.01
        config['num_mu_bins'] = 8
        config['num_phi_bins'] = 16
        config['solution_accuracy'] = 1e-4
        config['tautol'] = 0.1
        solvers = at3d.containers.SolversDict()
        for wavelength in wavelengths:

            #mie table and medium doesn't matter here as it is overwritten by property file.
            #just need it to initialize a solver.
            mie_mono_table = at3d.mie.get_mono_table('Water',(wavelength,wavelength), max_integration_radius=41.0,
                                                        relative_dir='../mie_tables', verbose=False)
            cloud_size_distribution = at3d.size_distribution.get_size_distribution_grid(
                                mie_mono_table.radius.data,
                                size_distribution_function=size_distribution_function,
                                particle_density=1.0,
                                reff={'coord_min':5.0, 'coord_max': 25.0, 'npoints': 10,
                                'spacing': 'linear', 'units': 'micron'},
                                alpha={'coord_min':6.9, 'coord_max': 7.1, 'npoints': 2,
                                'spacing': 'linear', 'units': 'unitless'}
                                )
            poly_table = at3d.mie.get_poly_table(cloud_size_distribution,mie_mono_table)
            cloud_optical_scatterer = at3d.medium.table_to_grid(cloud_scatterer_on_rte_grid, poly_table)

            solvers.add_solver(wavelength, at3d.solver.RTE(
                                            numerical_params=config,
                                            medium={'cloud': cloud_optical_scatterer},
                                            source=at3d.source.solar(wavelength,-0.5, 0.0, solarflux=1.0),
                                            surface=at3d.surface.lambertian(albedo=0.05),
                                            num_stokes=3,
                                            name=None,
                                            atmosphere=None
                                            )
                                        )

        solver = solvers[0.672]
        solve_prop(solver, filename = 'data/rico32x36x26w672.prp')
        shdom_source = parse_shdom_output('data/shdom_verification_source_out.out', comment='*')
        cls.truth = shdom_source.T
        cls.testing = solver._source[:, :solver._npts]
        solver._correctinterpolate = False
        integrated_rays = solver.integrate_to_sensor(sensor)
        cls.integrated_rays = integrated_rays
        cls.radiances = parse_shdom_output('data/rico32x36x26w672ar.out', comment='!')

    def test_solver(self):
        print(np.max(np.abs(self.testing-self.truth)))
        print(np.argmax(np.abs(self.testing-self.truth)))
        print(np.sqrt(np.mean((self.testing-self.truth)**2))/np.mean(self.truth))
        self.assertTrue(np.allclose(self.testing, self.truth, atol=5e-7))

    def test_radiance(self):
        print(np.sqrt(np.mean((self.integrated_rays.I.data-self.radiances[:,2].data)**2))/np.mean(self.radiances[:,2].data))
        self.assertTrue(np.allclose(self.integrated_rays.I.data, self.radiances[:,2].data,atol=3e-3))# atol=3e-3))

    def test_Q(self):
        self.assertTrue(np.allclose(self.integrated_rays.Q.data, self.radiances[:,3].data, atol=2e-4))

    def test_U(self):
        self.assertTrue(np.allclose(self.integrated_rays.U.data, self.radiances[:,4].data, atol=7e-5))

class Parallelization_Subdivide_Rays(TestCase):

    @classmethod
    def setUpClass(cls):

        reff = 10.0
        ext = 20.0
        rte_grid = at3d.grid.make_grid(0.05,16,
                                   0.05,14,
                                   np.linspace(0.1,0.7,15))

        rte_grid['density'] = (['x','y','z'], np.ones((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)))
        rte_grid['reff'] = (['x','y','z'], np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+np.linspace(5.0,10.0,rte_grid.z.size))
        rte_grid['veff'] = (['x','y','z'] ,np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+0.1)

        #resample the cloud onto the rte_grid
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, rte_grid)

        Sensordict = at3d.containers.SensorsDict()
        misr_list = []
        sensor_zenith_list = [75.0,60.0,45.6,26.1]*2 + [0.0]
        sensor_azimuth_list = [90]*4 + [-90]*4 +[0.0]
        wavelengths = [3.4]
        for zenith,azimuth in zip(sensor_zenith_list,sensor_azimuth_list):
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelengths[0], cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, azimuth, zenith,
                                                     altitude='TOA', stokes=['I'])
                                 )
        wavelengths = [0.8]
        for wavelength in wavelengths:
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, 0.0,0.0,
                                                     altitude='TOA', stokes=['I'],
                                                                  sub_pixel_ray_args={
                                                                      'method':at3d.sensor.gaussian,
                                                                      'degree': 2
                                                                  }))
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, 2,2.0,
                                                     altitude='TOA', stokes=['I'],
                                                                  sub_pixel_ray_args={
                                                                      'method':at3d.sensor.gaussian,
                                                                      'degree': 3
                                                                  }))
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, 50,50.0,
                                                     altitude='TOA', stokes=['I'],
                                                                  sub_pixel_ray_args={
                                                                      'method':at3d.sensor.gaussian,
                                                                      'degree': 3
                                                                  }))
        wavelengths = [1.6]
        for wavelength in wavelengths:
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, 0.0,0.0,
                                                     altitude='TOA', stokes=['I'],
                                                                  sub_pixel_ray_args={
                                                                      'method':at3d.sensor.gaussian,
                                                                      'degree': 2
                                                                  }))
        wavelengths = [2.0]
        for wavelength in wavelengths:
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,
                                                                   0.04,0.04, 0.0,0.0,
                                                     altitude='TOA', stokes=['I']))
        solvers = at3d.containers.SolversDict({3.4: None, 0.8: None, 1.6:None, 2.0:None})
        rte_sensors, sensor_mapping = Sensordict.sort_sensors(solvers)
        keys, ray_start_end, pixel_start_end = at3d.parallel.subdivide_raytrace_jobs(rte_sensors, 4)
        cls.ray_start_end = ray_start_end
        cls.pixel_start_end = pixel_start_end

    def test_rays(self):
        self.assertEqual(self.ray_start_end, [(0, 3700),
                                             (3700, 7400),
                                             (0, 4590),
                                             (4590, 9180),
                                             (9180, 13770),
                                             (0, 1440),
                                             (0, 360)])

    def test_pixels(self):
        self.assertEqual(self.pixel_start_end, [(0, 3700),
                                                 (3700, 7400),
                                                 (0, 710),
                                                 (710, 1220),
                                                 (1220, 1730),
                                                 (0, 360),
                                                 (0, 360)])
#
class Parallelization_No_SubpixelRays(TestCase):
    @classmethod
    def setUpClass(cls):

        reff = 0.5
        ext = 20.0
        rte_grid = at3d.grid.make_grid(0.05,13,
                                   0.05,13,
                                   np.linspace(0.1,0.7,13))

        rte_grid['density'] = (['x','y','z'], np.ones((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)))
        rte_grid['reff'] = (['x','y','z'], np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+reff)
        rte_grid['veff'] = (['x','y','z'] ,np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+0.1)

        #resample the cloud onto the rte_grid
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, rte_grid)

        #define any necessary variables for microphysics here.
        size_distribution_function = at3d.size_distribution.gamma

        #define sensors.
        Sensordict = at3d.containers.SensorsDict()
        Sensordict2 = at3d.containers.SensorsDict()
        misr_list = []
        sensor_zenith_list = [75.0,60.0,45.6,26.1]*2 + [0.0]
        sensor_azimuth_list = [90]*4 + [-90]*4 +[0.0]
        wavelengths = [0.86,0.86,0.86,1.38,1.38,2.2,2.2,3.4,3.4]
        for zenith,azimuth,wavelength in zip(sensor_zenith_list,sensor_azimuth_list,wavelengths):
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,0.04,0.04, azimuth, zenith,
                                                     altitude='TOA', stokes=['I'])
                                 )
            Sensordict2.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,0.04,0.04, azimuth, zenith,
                                                     altitude='TOA', stokes=['I'])
            )

        #Define the RTE solvers needed to model the measurements and
        #calculate optical properties.
        wavelengths = Sensordict.get_unique_solvers()

        cloud_poly_tables = OrderedDict()
        solvers = at3d.containers.SolversDict()

        for wavelength in wavelengths:

            #optical properties from mie calculations.
            mie_mono_table = at3d.mie.get_mono_table('Water',(wavelength,wavelength),
                                                      max_integration_radius=10.0,
                                                      minimum_effective_radius=0.1,
                                                      relative_dir='../mie_tables',
                                                      verbose=False)
            #mie_mono_table.to_netcdf('./mie_tables/MieTable_{}.nc'.format(reff))
            cloud_size_distribution = at3d.size_distribution.get_size_distribution_grid(
                                                                    mie_mono_table.radius.data,
                                size_distribution_function=size_distribution_function,particle_density=1.0,
                                reff={'coord_min':0.2, 'coord_max': 1.0, 'npoints': 10,
                                'spacing': 'logarithmic', 'units': 'micron'},
                                veff={'coord_min':0.09, 'coord_max': 0.11, 'npoints': 12,
                                'spacing': 'linear', 'units': 'unitless'}
                                )
            poly_table = at3d.mie.get_poly_table(cloud_size_distribution,mie_mono_table)
            optical_properties = at3d.medium.table_to_grid(cloud_scatterer_on_rte_grid, poly_table)
            optical_properties['ssalb'][:,:,:] = 1.0
            extinction = np.zeros(optical_properties.extinction.shape)
            np.random.seed(1)
            extinction[1:-1,1:-1,1:-1] = ext + np.random.uniform(low=0.0,high=10.0,size=(11,11,11))
            #extinction[a,b,c] += step
            optical_properties['legcoef'][:,1:,:] = 0.0
            optical_properties['extinction'][:,:,:] = extinction
            cloud_poly_tables[wavelength] = poly_table
            config = at3d.configuration.get_config('../default_config.json')
            config['num_mu_bins'] = 4
            config['num_phi_bins'] = 8
            config['split_accuracy'] = 0.1
            config['spherical_harmonics_accuracy'] = 0.0
            config['solution_accuracy'] = 1e-4
            config['tautol'] = 0.2
            config['transcut'] = 5e-5
            solver = at3d.solver.RTE(numerical_params=config,
                                            medium={'cloud': optical_properties},
                                           source=at3d.source.solar(wavelength, -1*np.cos(np.deg2rad(60.0)),0.0,solarflux=1.0),
                                           surface=at3d.surface.ocean_unpolarized(surface_wind_speed=10.0,
                                                                                  pigmentation=0.0),
                                            num_stokes=1,
                                            name=None
                                           )
            solver._init_solution()
            solvers.add_solver(wavelength, solver)

        Sensordict.get_measurements(solvers, maxiter=100, n_jobs=1, verbose=False)
        #Sensordict2.get_measurements(solvers, maxiter=100, n_jobs=1, verbose=False)
        #Sensordict['MISR']['sensor_list'][0].to_netcdf('data/RenderedSensorReference_nosubpixel.nc')

        cls.solvers = solvers
        cls.Sensordict = Sensordict
        cls.Sensordict2 = Sensordict2

    # def test_radiance(self):
    #     self.assertTrue(all([np.allclose(self.Sensordict2['MISR']['sensor_list'][i].I, self.Sensordict['MISR']['sensor_list'][i].I) for i in range(9)]))

    def test_no_subpixel_args_reference(self):
        test = xr.open_dataset('data/RenderedSensorReference_nosubpixel.nc')
        diff = test.I.data - self.Sensordict['MISR']['sensor_list'][0].I.data
        print(np.abs(diff).max())
        print(np.argmax(np.abs(diff)), diff.shape)
        print(np.sqrt(np.mean(diff**2)))
        xr.testing.assert_allclose(test, self.Sensordict['MISR']['sensor_list'][0], rtol=1e-5)


class Parallelization_SubpixelRays(TestCase):
    @classmethod
    def setUpClass(cls):

        reff = 0.5
        ext = 20.0
        rte_grid = at3d.grid.make_grid(0.05,13,
                                   0.05,13,
                                   np.linspace(0.1,0.7,13))

        rte_grid['density'] = (['x','y','z'], np.ones((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)))
        rte_grid['reff'] = (['x','y','z'], np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+reff)
        rte_grid['veff'] = (['x','y','z'] ,np.zeros((rte_grid.x.size, rte_grid.y.size, rte_grid.z.size))+0.1)

        #resample the cloud onto the rte_grid
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, rte_grid)

        #define any necessary variables for microphysics here.
        size_distribution_function = at3d.size_distribution.gamma

        #define sensors.
        Sensordict = at3d.containers.SensorsDict()
        Sensordict2 = at3d.containers.SensorsDict()
        misr_list = []
        sensor_zenith_list = [75.0,60.0,45.6,26.1]*2 + [0.0]
        sensor_azimuth_list = [90]*4 + [-90]*4 +[0.0]
        wavelengths = [0.86,0.86,0.86,1.38,1.38,2.2,2.2,3.4,3.4]
        for zenith,azimuth,wavelength in zip(sensor_zenith_list,sensor_azimuth_list,wavelengths):
            Sensordict.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,0.04,0.04, azimuth, zenith,
                                                     altitude='TOA', stokes=['I'],
                                                     sub_pixel_ray_args={'method': at3d.sensor.gaussian,
                                                     'degree':4})
                                 )
            Sensordict2.add_sensor('MISR',
                            at3d.sensor.orthographic_projection(wavelength, cloud_scatterer_on_rte_grid,0.04,0.04, azimuth, zenith,
                                                     altitude='TOA', stokes=['I'],
                                                  sub_pixel_ray_args={'method': at3d.sensor.gaussian,
                                                  'degree':4})
            )

        #Define the RTE solvers needed to model the measurements and
        #calculate optical properties.
        wavelengths = Sensordict.get_unique_solvers()

        cloud_poly_tables = OrderedDict()
        solvers = at3d.containers.SolversDict()

        for wavelength in wavelengths:

            #optical properties from mie calculations.
            mie_mono_table = at3d.mie.get_mono_table('Water',(wavelength,wavelength),
                                                      max_integration_radius=10.0,
                                                      minimum_effective_radius=0.1,
                                                      relative_dir='../mie_tables',
                                                      verbose=False)

            cloud_size_distribution = at3d.size_distribution.get_size_distribution_grid(
                                                                    mie_mono_table.radius.data,
                                size_distribution_function=size_distribution_function,particle_density=1.0,
                                reff={'coord_min':0.2, 'coord_max': 1.0, 'npoints': 10,
                                'spacing': 'logarithmic', 'units': 'micron'},
                                veff={'coord_min':0.09, 'coord_max': 0.11, 'npoints': 12,
                                'spacing': 'linear', 'units': 'unitless'}
                                )
            poly_table = at3d.mie.get_poly_table(cloud_size_distribution,mie_mono_table)
            optical_properties = at3d.medium.table_to_grid(cloud_scatterer_on_rte_grid, poly_table)
            optical_properties['ssalb'][:,:,:] = 1.0
            extinction = np.zeros(optical_properties.extinction.shape)
            np.random.seed(1)
            extinction[1:-1,1:-1,1:-1] = ext + np.random.uniform(low=0.0,high=10.0,size=(11,11,11))
            #extinction[a,b,c] += step
            optical_properties['legcoef'][:,1:,:] = 0.0
            optical_properties['extinction'][:,:,:] = extinction
            cloud_poly_tables[wavelength] = poly_table
            config = at3d.configuration.get_config('../default_config.json')
            config['num_mu_bins'] = 4
            config['num_phi_bins'] = 8
            config['split_accuracy'] = 0.1
            config['spherical_harmonics_accuracy'] = 0.0
            config['solution_accuracy'] = 1e-4
            config['tautol'] = 0.2
            config['transcut'] = 5e-5
            solver = at3d.solver.RTE(numerical_params=config,
                                            medium={'cloud': optical_properties},
                                           source=at3d.source.solar(wavelength, -1*np.cos(np.deg2rad(60.0)),0.0,solarflux=1.0),
                                           surface=at3d.surface.ocean_unpolarized(surface_wind_speed=10.0,
                                                                                  pigmentation=0.0),
                                            num_stokes=1,
                                            name=None
                                           )
            solvers.add_solver(wavelength,solver)

        Sensordict.get_measurements(solvers, maxiter=100, n_jobs=8, verbose=False)
        Sensordict2.get_measurements(solvers, maxiter=100, n_jobs=1, verbose=False)

        #Sensordict['MISR']['sensor_list'][0].to_netcdf('data/RenderedSensorReference_subpixelargs.nc')
        cls.solvers = solvers
        cls.Sensordict = Sensordict
        cls.Sensordict2 = Sensordict2

    def test_subpixel_args(self):
       self.assertTrue(all([np.allclose(self.Sensordict2['MISR']['sensor_list'][i].I, self.Sensordict['MISR']['sensor_list'][i].I) for i in range(9)]))

    def test_subpixel_args_reference(self):
        test = xr.open_dataset('data/RenderedSensorReference_subpixelargs.nc')
        diff = test.I.data - self.Sensordict['MISR']['sensor_list'][0].I.data
        print(np.abs(diff).max())
        print(np.argmax(np.abs(diff)), diff.shape)
        print(np.sqrt(np.mean(diff**2)))
        xr.testing.assert_allclose(test, self.Sensordict['MISR']['sensor_list'][0], rtol=1e-5)


class Verify_Lambertian_Surfaces(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        variable_lambertian = at3d.surface.lambertian(albedo=np.linspace(0.0,0.3- (0.3-0.0)/50.0,50)[:,np.newaxis],
                                                       ground_temperature=288.0,delx=0.02,dely=0.04)
        # variable_ocean = at3d.surface.ocean_unpolarized(surface_wind_speed = np.linspace(4.0, 12.0-(12.0-4.0)/50.0,50)[:,np.newaxis],
        #                                                 pigmentation = np.zeros((50,1)), ground_temperature=288.0,delx=0.02,dely=0.04)
        solver = at3d.solver.RTE(numerical_params=config,
                                        medium={'rayleigh': rayleigh[0.85]},
                                       source=at3d.source.solar(0.85, -0.707, 0.0, solarflux=1.0),
                                       surface=variable_lambertian,
                                        num_stokes=1,
                                        name=None,
                                        atmosphere=None)

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes = parse_shdom_output('data/brdf_L1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_L1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,-1], self.integrated_rays.I.data, atol=9e-6))

class Verify_Ocean_Unpolarized_Surfaces(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        variable_ocean = at3d.surface.ocean_unpolarized(
                                surface_wind_speed = np.linspace(4.0, 12.0-(12.0-4.0)/50.0,50)[:,np.newaxis],
                                pigmentation = np.zeros((50,1)),
                                ground_temperature=288.0,
                                delx=0.02, dely=0.04
                                )
        solver = at3d.solver.RTE(
                                numerical_params=config,
                                medium={'rayleigh': rayleigh[0.85]},
                                source=at3d.source.solar(0.85,-0.707, 0.0, solarflux=1.0),
                                surface=variable_ocean,
                                num_stokes=1,
                                name=None,
                                atmosphere=None
                                )

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes = parse_shdom_output('data/brdf_O1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_O1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,-1], self.integrated_rays.I.data, atol=9e-6))


class Verify_RPV_Surfaces(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        k = np.linspace(0.5, 1.0 - 0.5/50, 50)[:,np.newaxis]
        theta = np.ones(50)[:,np.newaxis]*-0.24
        rho0 = np.ones(50)[:,np.newaxis]*0.1
        surface = at3d.surface.RPV_unpolarized(rho0,k,theta, ground_temperature=288.0, delx=0.02,dely=0.02)
        solver = at3d.solver.RTE(numerical_params=config,
                                                medium={'rayleigh': rayleigh[0.85]},
                                               source=at3d.source.solar(0.85,-0.707, 0.0, solarflux=1.0),
                                               surface=surface,
                                                num_stokes=1,
                                                name=None,
                                                atmosphere=None)

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes =  parse_shdom_output('data/brdf_R1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_R1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,-1], self.integrated_rays.I.data, atol=9e-6))


class Verify_WaveFresnel_Surfaces(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        real_refractive_index =np.ones(50)[:,np.newaxis]*1.33
        imaginary_refractive_index = np.zeros(50)[:,np.newaxis]
        surface_wind_speed = np.linspace(4.0, 12.0-8.0/50, 50)[:,np.newaxis]
        surface = at3d.surface.wave_fresnel(real_refractive_index, imaginary_refractive_index, surface_wind_speed,
                                            ground_temperature=288.0, delx=0.02,dely=0.02)
        solver = at3d.solver.RTE(numerical_params=config,
                                                medium={'rayleigh': rayleigh[0.85]},
                                               source=at3d.source.solar(0.85, -0.707, 0.0, solarflux=1.0),
                                               surface=surface,
                                                num_stokes=3,
                                                name=None,
                                                atmosphere=None)

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes = parse_shdom_output('data/brdf_W1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_W1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,2], self.integrated_rays.I.data, atol=9e-6))

    def test_Q(self):
        self.assertTrue(np.allclose(self.radiances[:,3], self.integrated_rays.Q.data, atol=9e-6))

    def test_U(self):
        self.assertTrue(np.allclose(self.radiances[:,4], self.integrated_rays.U.data, atol=9e-6))


class Verify_Diner_Surfaces(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        a = np.ones(50)[:,np.newaxis]*0.2
        k = np.ones(50)[:,np.newaxis]*0.8
        b = np.ones(50)[:,np.newaxis]*0.3
        zeta = np.linspace(0., 1.0 - 1.0/50, 50)[:, np.newaxis]
        sigma = np.ones(50)[:,np.newaxis] * -1.0

        surface = at3d.surface.diner(a, k, b, zeta, sigma, ground_temperature=288.0, delx=0.02,dely=0.02)
        solver = at3d.solver.RTE(
                    numerical_params=config,
                    medium={'rayleigh': rayleigh[0.85]},
                    source=at3d.source.solar(0.85, -0.707, 0.0, solarflux=1.0),
                    surface=surface,
                    num_stokes=3,
                    name=None,
                    atmosphere=None
                    )

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes = parse_shdom_output('data/brdf_D1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_D1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,2], self.integrated_rays.I.data, atol=9e-6))

    def test_Q(self):
        self.assertTrue(np.allclose(self.radiances[:,3], self.integrated_rays.Q.data, atol=9e-6))

    def test_U(self):
        self.assertTrue(np.allclose(self.radiances[:,4], self.integrated_rays.U.data, atol=9e-6))

class Verify_ZeroGasAbsorption(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        variable_lambertian = at3d.surface.lambertian(albedo=np.linspace(0.0,0.3- (0.3-0.0)/50.0,50)[:,np.newaxis],
                                                       ground_temperature=288.0,delx=0.02,dely=0.04)
        atmosphere = xr.Dataset(
            data_vars={
            'gas_absorption': (['x', 'y', 'z'], np.zeros((rayleigh[0.85].x.size, rayleigh[0.85].y.size,
                                                        rayleigh[0.85].z.size)))
            },
            coords={
            'x': rayleigh[0.85].x,
            'y': rayleigh[0.85].y,
            'z': rayleigh[0.85].z
            }
        )
        atmosphere['delx'] = rayleigh[0.85].delx
        atmosphere['dely'] = rayleigh[0.85].dely
        solver = at3d.solver.RTE(numerical_params=config,
                                        medium={'rayleigh': rayleigh[0.85]},
                                       source=at3d.source.solar(0.85, -0.707, 0.0, solarflux=1.0),
                                       surface=variable_lambertian,
                                        num_stokes=1,
                                        name=None,
                                        atmosphere=atmosphere)

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.fluxes = parse_shdom_output('data/brdf_L1f.out', comment='!')
        cls.radiances = parse_shdom_output('data/brdf_L1r.out', comment='!')

    def test_flux_direct(self):
        self.assertTrue(np.allclose(self.fluxes[:,4],self.solver.fluxes.flux_direct[:,0,0].data, atol=4e-6))

    def test_flux_down(self):
        self.assertTrue(np.allclose(self.fluxes[:,3],self.solver.fluxes.flux_down[:,0,0].data, atol=4e-6))

    def test_flux_up(self):
        self.assertTrue(np.allclose(self.fluxes[:,2],self.solver.fluxes.flux_up[:,0,0].data, atol=4e-6))

    def test_radiance(self):
        self.assertTrue(np.allclose(self.radiances[:,-1], self.integrated_rays.I.data, atol=9e-6))

class Verify_NonuniformGasAbsorption(TestCase):
    @classmethod
    def setUpClass(cls):

        sensor, rayleigh, config = get_basic_state_for_surface()
        config['transcut'] = 0.0
        x = np.linspace(0,1.0-1.0/50,50)
        y = np.zeros(50)
        z = np.ones(50)*30.0
        mu = np.array([1.0]*50)
        phi = np.array([0.0]*50)

        sensor = at3d.sensor.make_sensor_dataset(x.ravel(),y.ravel(),z.ravel(),mu.ravel(),np.deg2rad(phi.ravel()),['I'],
                                                 0.85, fill_ray_variables=True)

        lambertian = at3d.surface.lambertian(albedo=0.04)
        atmosphere = xr.Dataset(
            data_vars={
            'gas_absorption': (['x', 'y', 'z'], np.ones((rayleigh[0.85].x.size, rayleigh[0.85].y.size,
                                                        rayleigh[0.85].z.size))*
                                                        np.linspace(0.0, 1,rayleigh[0.85].x.size)[:, np.newaxis, np.newaxis])
            },
            coords={
            'x': rayleigh[0.85].x,
            'y': rayleigh[0.85].y,
            'z': rayleigh[0.85].z
            }
        )
        rayleigh[0.85]['extinction'] *= 0.0
        atmosphere['delx'] = rayleigh[0.85].delx
        atmosphere['dely'] = rayleigh[0.85].dely
        solver = at3d.solver.RTE(numerical_params=config,
                                        medium={'rayleigh': rayleigh[0.85]},
                                       source=at3d.source.solar(0.85, -1.0, 0.0, solarflux=1.0),
                                       surface=lambertian,
                                        num_stokes=1,
                                        name=None,
                                        atmosphere=atmosphere)

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        tau = np.linspace(0.0, 1, rayleigh[0.85].x.size)*30.0

        rad = 1.0*np.exp(-tau)*0.04/np.pi * np.exp(-tau)
        cls.tau = tau
        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.rad = rad

    def test_radiance(self):
        print(np.max(np.abs(self.integrated_rays.I.data-self.rad)))
        print(self.integrated_rays.I.data, self.rad)
        self.assertTrue(np.allclose(self.integrated_rays.I.data, self.rad, atol=2e-7))

class Verify_Thermal(TestCase):
    @classmethod
    def setUpClass(cls):

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.0
        config['spherical_harmonics_accuracy'] = 0.0
        config['num_mu_bins'] = 128
        config['num_phi_bins'] = 256
        config['solution_accuracy'] = 1e-5
        config['x_boundary_condition'] = 'periodic'
        config['y_boundary_condition'] = 'periodic'
        config['ip_flag'] = 1
        config['tautol'] = 0.1
        config['deltam'] = False

        rte_grid = at3d.grid.make_grid(0.02, 50, 0.02, 1,
                                   np.array([0,3.0,6.0,9.0,12.0,15.0,18.0,21.0,24.0,27.0,30.0]))

        atmosphere = xr.Dataset(
            data_vars = {
                'temperature': ('z', np.array([288.0]*11)),
                'pressure': ('z', np.ones(rte_grid.z.size)*0.0)
                            },
            coords = {'z': rte_grid.z.data}
        )
        wavelengths = np.atleast_1d(11.0)
        rayleigh = at3d.rayleigh.to_grid(wavelengths,atmosphere , rte_grid)

        x = np.linspace(0,1.0-1.0/50,50)
        y = np.zeros(50)
        z = np.ones(50)*30.0
        mu = np.array([1.0]*50)
        phi = np.array([0.0]*50)

        sensor = at3d.sensor.make_sensor_dataset(x.ravel(),y.ravel(),z.ravel(),mu.ravel(),np.deg2rad(phi.ravel()),['I'],
                                                 11.0, fill_ray_variables=True)

        lambertian = at3d.surface.lambertian(albedo=0.5, ground_temperature=300.0)
        rayleigh[11.0]['extinction'] = (['x','y','z'], np.ones((rayleigh[11.0].x.size, rayleigh[11.0].y.size,
                                                                rayleigh[11.0].z.size))*
                                                        np.linspace(0.001, 0.5,rayleigh[11.0].x.size)[:, np.newaxis, np.newaxis])
        rayleigh[11.0]['ssalb']= (['x','y','z'], np.zeros((rayleigh[11.0].x.size, rayleigh[11.0].y.size,
                                                                rayleigh[11.0].z.size)))
        solver = at3d.solver.RTE(numerical_params=config,
                                        medium={'rayleigh': rayleigh[11.0]},
                                       source=at3d.source.thermal(11.0),
                                       surface=lambertian,
                                        num_stokes=1,
                                        name=None,
                                        atmosphere=rayleigh[11.0])

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        optical_path = 30.0*np.linspace(0.001, 0.5,rayleigh[11.0].x.size)
        transmittance = np.exp(-1*optical_path)
        from scipy.special import exp1
        rad = (1.0 - 0.5)*at3d.util.planck_function(300.0, 11.0)*transmittance + \
              at3d.util.planck_function(288.0, 11.0)*(1.0-transmittance) + \
              transmittance*(0.5*at3d.util.planck_function(288.0, 11.0)*(
                -transmittance*(1.0 - optical_path) - optical_path**2 * exp1(optical_path) + 1)
              )

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.rad = rad

    def test_radiance(self):
        #print(self.rad,self.rad2, self.integrated_rays.I.data)
        print(100*np.max(np.abs(self.rad - self.integrated_rays.I.data)/self.rad))
        print(np.max(np.abs(self.rad - self.integrated_rays.I.data)))
        self.assertTrue(np.allclose(self.integrated_rays.I.data, self.rad, atol=3e-4))

class VerifyCombined(TestCase):
    @classmethod
    def setUpClass(cls):

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.0
        config['spherical_harmonics_accuracy'] = 0.0
        config['num_mu_bins'] = 128
        config['num_phi_bins'] = 256
        config['solution_accuracy'] = 1e-5
        config['x_boundary_condition'] = 'periodic'
        config['y_boundary_condition'] = 'periodic'
        config['ip_flag'] = 1
        config['tautol'] = 0.1
        config['deltam'] = False

        rte_grid = at3d.grid.make_grid(0.02, 50, 0.02, 1,
                                   np.array([0,3.0,6.0,9.0,12.0,15.0,18.0,21.0,24.0,27.0,30.0]))

        atmosphere = xr.Dataset(
            data_vars = {
                'temperature': ('z', np.array([288.0]*11)),
                'pressure': ('z', np.ones(rte_grid.z.size)*0.0)
                            },
            coords = {'z': rte_grid.z.data}
        )
        wavelengths = np.atleast_1d(11.0)
        rayleigh = at3d.rayleigh.to_grid(wavelengths,atmosphere , rte_grid)

        x = np.linspace(0,1.0-1.0/50,50)
        y = np.zeros(50)
        z = np.ones(50)*30.0
        mu = np.array([1.0]*50)
        phi = np.array([0.0]*50)

        sensor = at3d.sensor.make_sensor_dataset(x.ravel(),y.ravel(),z.ravel(),mu.ravel(),np.deg2rad(phi.ravel()),['I'],
                                                 11.0, fill_ray_variables=True)

        lambertian = at3d.surface.lambertian(albedo=0.5, ground_temperature=300.0)
        rayleigh[11.0]['extinction'] = (['x','y','z'], np.ones((rayleigh[11.0].x.size, rayleigh[11.0].y.size,
                                                                rayleigh[11.0].z.size))*
                                                        np.linspace(0.001, 0.5,rayleigh[11.0].x.size)[:, np.newaxis, np.newaxis])
        rayleigh[11.0]['ssalb']= (['x','y','z'], np.zeros((rayleigh[11.0].x.size, rayleigh[11.0].y.size,
                                                                rayleigh[11.0].z.size)))
        solver = at3d.solver.RTE(numerical_params=config,
                                        medium={'rayleigh': rayleigh[11.0]},
                                       source=at3d.source.combined(11.0, -1.0, 0.0, solarflux=1.0),
                                       surface=lambertian,
                                        num_stokes=1,
                                        name=None,
                                        atmosphere=rayleigh[11.0])

        solver.solve(maxiter=100, verbose=False)
        integrated_rays = solver.integrate_to_sensor(sensor)

        optical_path = 30.0*np.linspace(0.001, 0.5,rayleigh[11.0].x.size)
        transmittance = np.exp(-1*optical_path)
        from scipy.special import exp1
        rad = 0.5*transmittance*transmittance/np.pi + (1.0 - 0.5)*at3d.util.planck_function(300.0, 11.0)*transmittance + \
              at3d.util.planck_function(288.0, 11.0)*(1.0-transmittance) + \
              transmittance*(0.5*at3d.util.planck_function(288.0, 11.0)*(
                -transmittance*(1.0 - optical_path) - optical_path**2 * exp1(optical_path) + 1)
              )

        cls.integrated_rays = integrated_rays
        cls.solver = solver
        cls.rad = rad

    def test_radiance(self):
        #print(self.rad,self.rad2, self.integrated_rays.I.data)
        print(100*np.max(np.abs(self.rad - self.integrated_rays.I.data)/self.rad))
        print(np.max(np.abs(self.rad - self.integrated_rays.I.data)))
        self.assertTrue(np.allclose(self.integrated_rays.I.data, self.rad, atol=3e-4))

class VerifyRadianceIntegration(TestCase):

    @classmethod
    def setUpClass(cls):

        rte_grid = at3d.grid.make_grid(0.1,2,
                                  0.1,2,
                                  np.linspace(0.0,1.0,3))



        errors = []
        errors2 = []
        planck_error = []
        optical_paths = np.logspace(-3,1,11)
        for planck1 in np.logspace(2,np.log10(300.0),11):
            for optpath in optical_paths:

                cloud_scatterer = rte_grid.copy(deep=True)
                extinction = np.zeros((2,2,3))
                extinction[:,:,:] = optpath
                cloud_scatterer['extinction'] = (['x','y','z'], extinction)
                cloud_scatterer['ssalb'] = (['x','y','z'], np.zeros((2,2,3)))
                legendre = np.zeros((6,2,1))
                legendre[0,0] = 1.0
                cloud_scatterer['legcoef'] = (['stokes_index', 'legendre_index','table_index'], legendre)

                cloud_scatterer['table_index'] = (['num_micro', 'x','y','z'],
                                                  np.ones((1,2,2,3),dtype=int))

                cloud_scatterer['stokes_index'] = (['stokes_index'], np.array(['P11', 'P22', 'P33', 'P44', 'P12', 'P34']))
                cloud_scatterer['phase_weights'] = (['num_micro', 'x','y','z'],
                                                  np.ones((1,2,2,3)))
                cloud_scatterer['interp_method'] = 'exact'

                test_atmosphere = rte_grid.copy(deep=True)
                test_temperature = np.repeat(np.repeat(np.linspace(planck1,300.0, 2)[:,np.newaxis, np.newaxis],2, axis=1),3,axis=-1)
                test_atmosphere['temperature'] = (['x','y','z'], test_temperature)

                config = at3d.configuration.get_config('../default_config.json')
                config['split_accuracy'] = 0.0
                config['deltam'] = False
                solver_grid = at3d.solver.RTE(
                    numerical_params=config,
                    surface=at3d.surface.lambertian(0.0, ground_temperature=0.0),
                    source=at3d.source.thermal(11.0),
                    medium={'cloud': cloud_scatterer},
                    num_stokes=1,
                    atmosphere=test_atmosphere
                )

                solver_grid._init_solution()


                npts,ncells,newpoints = at3d.core.divide_cell(
                    npts=solver_grid._npts,
                    ncells=solver_grid._ncells,
                    gridptr=solver_grid._gridptr,
                    neighptr=solver_grid._neighptr,
                    treeptr=solver_grid._treeptr,
                    cellflags=solver_grid._cellflags,
                    gridpos=solver_grid._gridpos,
                    icell=9,
                    idir=1
                )
                solver_grid._npts=npts
                solver_grid._ncells = ncells

                at3d.core.interpolate_point(
                    newpoints=newpoints,
                    npts=solver_grid._npts,
                    nstokes=solver_grid._nstokes,
                    ml=solver_grid._ml,
                    mm=solver_grid._mm,
                    nlm=solver_grid._nlm,
                    nstleg=solver_grid._nstleg,
                    nleg=solver_grid._nleg,
                    numphase=solver_grid._pa.numphase,
                    deltam=solver_grid._deltam,
                    bcflag=solver_grid._bcflag,
                    ipflag=solver_grid._ipflag,
                    accelflag=solver_grid._accelflag,
                    gridpos=solver_grid._gridpos,
                    srctype=solver_grid._srctype,
                    solarflux=solver_grid._solarflux,
                    solarmu=solver_grid._solarmu,
                    solaraz=solver_grid._solaraz,
                    ylmsun=solver_grid._ylmsun,
                    units=solver_grid._units,
                    waveno=solver_grid._waveno,
                    wavelen=solver_grid.wavelength,
                    extinct=solver_grid._extinct,
                    albedo=solver_grid._albedo,
                    legen=solver_grid._legen,
                    iphase=solver_grid._iphase,
                    temp=solver_grid._temp,
                    planck=solver_grid._planck,
                    dirflux=solver_grid._dirflux,
                    rshptr=solver_grid._rshptr,
                    radiance=solver_grid._radiance,
                    shptr=solver_grid._shptr,
                    source=solver_grid._source,
                    oshptr=solver_grid._oshptr,
                    npx=solver_grid._pa.npx,
                    npy=solver_grid._pa.npy,
                    npz=solver_grid._pa.npz,
                    delx=solver_grid._pa.delx,
                    dely=solver_grid._pa.dely,
                    xstart=solver_grid._pa.xstart,
                    ystart=solver_grid._pa.ystart,
                    zlevels=solver_grid._pa.zlevels,
                    tempp=solver_grid._pa.tempp,
                    extinctp=solver_grid._pa.extinctp,
                    albedop=solver_grid._pa.albedop,
                    legenp=solver_grid._pa.legenp,
                    extdirp=solver_grid._pa.extdirp,
                    iphasep=solver_grid._pa.iphasep,
                    nzckd=solver_grid._pa.nzckd,
                    zckd=solver_grid._pa.zckd,
                    gasabs=solver_grid._pa.gasabs,
                    extmin=solver_grid._extmin,
                    scatmin=solver_grid._scatmin,
                    cx=solver_grid._cx,
                    cy=solver_grid._cy,
                    cz=solver_grid._cz,
                    cxinv=solver_grid._cxinv,
                    cyinv=solver_grid._cyinv,
                    czinv=solver_grid._czinv,
                    di=solver_grid._di,
                    dj=solver_grid._dj,
                    dk=solver_grid._dk,
                    ipdirect=solver_grid._ipdirect,
                    delxd=solver_grid._delxd,
                    delyd=solver_grid._delyd,
                    xdomain=solver_grid._xdomain,
                    ydomain=solver_grid._ydomain,
                    epss=solver_grid._epss,
                    epsz=solver_grid._epsz,
                    uniformzlev=solver_grid._uniformzlev,
                    npart=solver_grid._npart,
                    maxig=solver_grid._maxig,
                    maxpg=solver_grid._maxpg,
                    total_ext=solver_grid._total_ext,
                    interpmethod=solver_grid._interpmethod,
                    ierr=0,
                    errmsg="          ",
                    phaseinterpwt=solver_grid._phaseinterpwt,
                    phasemax=solver_grid._phasemax,
                    nlegp=solver_grid._pa.nlegp,
                    maxnmicro=solver_grid._pa.max_num_micro,
                    phasewtp=solver_grid._pa.phasewtp,
                    nvolsrc=1,
                    volsrc=np.zeros((solver_grid._nstokes, 1),dtype=np.float32,order='F'),
                    volsrcgridptr=np.zeros((2,solver_grid._npts),dtype=np.int32,order='F'),
                    volsrcshptr=np.zeros(2, dtype=np.int32),
                )
                solver_grid.solve(100,init_solution=False,verbose=False)


                config = at3d.configuration.get_config('../default_config.json')
                config['split_accuracy'] = 0.0
                solver_ref = at3d.solver.RTE(
                    numerical_params=config,
                    surface=at3d.surface.lambertian(0.0, ground_temperature=0.0),
                    source=at3d.source.thermal(11.0),
                    medium={'cloud': cloud_scatterer},
                    num_stokes=1,
                    atmosphere=test_atmosphere
                )
                solver_ref.solve(100,verbose=False)

                sensor_ref = at3d.sensor.make_sensor_dataset(x=np.array([0.025]),
                                                    y=np.array([0.0]),
                                                    z=np.array([0.50]),
                                                    mu=np.array([1.0]),
                                                    phi=np.array([0.0]),
                                                           stokes=['I'],
                                                           wavelength=11.0,
                                                           fill_ray_variables=True)

                sensor_grid_good_interpolate = sensor_ref.copy(deep=True)
                sensor_grid_bad_interpolate = sensor_ref.copy(deep=True)

                integrated_sensor_ref = solver_ref.integrate_to_sensor(sensor_ref)
                integrated_sensor_grid_good = solver_grid.integrate_to_sensor(sensor_grid_good_interpolate)
                solver_grid._correctinterpolate = False
                integrated_sensor_grid_bad = solver_grid.integrate_to_sensor(sensor_grid_bad_interpolate)

                #analytical solution nadir.
                # design and verification . ..  Jones & Di Girolamo, 2018 https://doi.org/10.1175/JAS-D-17-0251.1
                optical_path = optpath

                transmittance1 = transmittance2 = np.exp(-optical_path/2)

                Ts = 0.0

                planck_surface = at3d.core.planck_function(
                    temp=Ts,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                )
                planck_atmosphere2 = 0.75*at3d.core.planck_function(
                    temp=planck1,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                ) + 0.25*at3d.core.planck_function(
                    temp=300.0,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                )

                planck_atmosphere1 = 0.5*at3d.core.planck_function(
                    temp=planck1,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                ) + 0.5*at3d.core.planck_function(
                    temp=0.5*planck1+0.5*300.0,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                )

                full_temperature = at3d.core.planck_function(
                    temp=0.75*planck1+0.25*300.0,
                    wavelen=11.0,
                    units='R',
                    waveno=[10000,10001]
                )

                analytic = planck_surface*transmittance1*transmittance2 + \
                            planck_atmosphere1*(1.0-transmittance1)
                analytic_unapprox = full_temperature*(1.0-transmittance1)
                error = (integrated_sensor_grid_bad.I.data[0]-analytic)/analytic
                errors2.append((integrated_sensor_grid_good.I.data[0]-analytic)/analytic)
                planck_error.append((planck_atmosphere1 - planck_atmosphere2)/planck_atmosphere2)
                errors.append(error)

        cls.errors = errors2

    def test_radiance(self):
        print(np.abs(self.errors).max())
        self.assertTrue(np.allclose(0.0, self.errors, atol=3e-4))

class VerifyMultiSpeciesSolverExactPhase(TestCase):

    @classmethod
    def setUpClass(cls):

        wavelengths = np.array([0.86])#sensor_dict.get_unique_solvers()
        size_distribution_function = at3d.size_distribution.gamma
        mie_mono_tables = OrderedDict()
        for wavelength in wavelengths:
            mie_mono_tables[wavelength] = at3d.mie.get_mono_table(
                'Water',(wavelength,wavelength),
                max_integration_radius=65.0,
                minimum_effective_radius=0.1,
                relative_dir='../mie_tables',
                verbose=False
            )

        rte_grid = at3d.grid.make_grid(0.02, 5, 0.02, 5, np.linspace(0.0, 1.0,11))

        optical_property_generator_cloud = at3d.medium.OpticalPropertyGenerator(
            'cloud',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(5.0,30.0,30),
            veff=np.linspace(0.08,0.2,20),
        )

        optical_property_generator_small = at3d.medium.OpticalPropertyGenerator(
            'aerosol',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(0.1,2.0,30),
            veff=np.linspace(0.08,0.2,20),
        )

        np.random.seed(1)

        cloud_scatterer = rte_grid.copy(deep=True)
        shape = (rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)
        cloud_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        cloud_scatterer['reff'] = (['x','y','z'], np.random.uniform(10.0,30.0,size=shape))
        cloud_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, cloud_scatterer)

        aerosol_scatterer = rte_grid.copy(deep=True)
        aerosol_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        #r = np.repeat(np.repeat(np.linspace(0.3,0.5, shape[-1])[None,None],shape[0],axis=0),shape[1],axis=1)
        aerosol_scatterer['reff'] = (['x','y','z'], np.random.uniform(0.3,0.5,size=shape))
        aerosol_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        aerosol_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, aerosol_scatterer)

        optical_properties_cloud = optical_property_generator_cloud(cloud_scatterer_on_rte_grid)
        optical_properties_aerosol = optical_property_generator_small(aerosol_scatterer_on_rte_grid)

        cloud = optical_properties_cloud[0.86]
        aerosol = optical_properties_aerosol[0.86]
        cloud['extinction'][:] = np.random.uniform(0.01,10.0,cloud.extinction.shape)
        cloud['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)
        aerosol['extinction'][:] = np.random.uniform(0.01,10.0,aerosol.extinction.shape)
        aerosol['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)

        mixture_exact = at3d.medium.mix_optical_properties(cloud, aerosol, maxnphase=800, asymmetry_tol=0.0, phase_tol=0.0)

        solvers_dict = at3d.containers.SolversDict()

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.0
        config['x_boundary_condition'] = 'periodic'
        config['y_boundary_condition'] = 'periodic'
        config['solution_accuracy'] = 1e-8
        config['num_mu_bins'] = 16
        config['num_phi_bins'] = 32
        config['deltam'] = True
        config['adapt_grid_factor'] = 5.0
        config['acceleration_flag'] = False

        solver1 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'cloud': cloud, 'aerosol': aerosol},
                num_stokes=3
            )
        solver2 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'mixture':mixture_exact},
                num_stokes=3
            )
        solvers_dict.add_solver(1, solver1)
        solvers_dict.add_solver(2, solver2)

        solvers_dict.solve(maxiter=100, verbose=False)

        print('WEIGHT SUM', solver1._phaseinterpwt.sum(axis=0).min())
        print('LEGCOEF1', solver1._legen[0].ravel())
        print('LEGCOEF2', solver2._legen[0].ravel())

        cls.extinct_exact = solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].extinction.data
        cls.scatter_exact = solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        cls.phase_exact = (solver1.medium['cloud'].legcoef.data[...,solver1.medium['cloud'].table_index-1]*solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data + \
                            solver1.medium['aerosol'].legcoef.data[...,solver1.medium['aerosol'].table_index-1]*solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data)/(
            solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        )
        cls.source_exact = solver1._source
        cls.phase_mixture = mixture_exact.legcoef[:,:,:].data.reshape((6,mixture_exact.legendre_index.size,1)+shape,order='F')
        cls.extinct_mixture = mixture_exact.extinction.data
        cls.scatter_mixture = (mixture_exact.ssalb*mixture_exact.extinction).data
        cls.source_mixture = solver2._source
        mu = np.linspace(0.05,1.0, 361)
        size = mu.size
        sensor_exact = at3d.sensor.make_sensor_dataset(x=[0.5]*size, y=[0.5]*size,z=np.array([1.0]*size),
                                           mu=mu,
                                           phi=np.array([0.0]*size),stokes=['I','Q','U'],fill_ray_variables=True,
                                                   wavelength=0.86)
        sensor_mixture = sensor_exact.copy(deep=True)
        cls.sensor_exact = solver1.integrate_to_sensor(sensor_exact)
        cls.sensor_mixture = solver1.integrate_to_sensor(sensor_mixture)

    def test_extinction(self):
        self.assertTrue(np.allclose(self.extinct_exact, self.extinct_mixture))

    def test_scatter(self):
        self.assertTrue(np.allclose(self.scatter_exact, self.scatter_mixture))

    def test_phase(self):
        print(np.max(np.abs(self.phase_exact-self.phase_mixture)))
        self.assertTrue(np.allclose(self.phase_exact, self.phase_mixture))

    def test_source(self):
        print(np.max(np.abs(self.source_exact-self.source_mixture)))
        self.assertTrue(np.allclose(self.source_exact, self.source_mixture,atol=6e-8))

    def test_intensity(self):
        print(np.max(np.abs(self.sensor_exact.I-self.sensor_mixture.I)))
        self.assertTrue(np.allclose(self.sensor_exact.I, self.sensor_mixture.I))

    def test_Q(self):
        print(np.max(np.abs(self.sensor_exact.Q-self.sensor_mixture.Q)))
        self.assertTrue(np.allclose(self.sensor_exact.Q, self.sensor_mixture.Q))

    def test_U(self):
        print(np.max(np.abs(self.sensor_exact.U-self.sensor_mixture.U)))
        self.assertTrue(np.allclose(self.sensor_exact.U, self.sensor_mixture.U))


class VerifyMultiSpeciesSolverTablePhase(TestCase):

    @classmethod
    def setUpClass(cls):

        wavelengths = np.array([0.86])#sensor_dict.get_unique_solvers()
        size_distribution_function = at3d.size_distribution.gamma
        mie_mono_tables = OrderedDict()
        for wavelength in wavelengths:
            mie_mono_tables[wavelength] = at3d.mie.get_mono_table(
                'Water',(wavelength,wavelength),
                max_integration_radius=65.0,
                minimum_effective_radius=0.1,
                relative_dir='../mie_tables',
                verbose=False
            )

        rte_grid = at3d.grid.make_grid(0.02, 5, 0.02, 5, np.linspace(0.0, 1.0,11))

        optical_property_generator_cloud = at3d.medium.OpticalPropertyGenerator(
            'cloud',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(5.0,30.0,30),
            veff=np.linspace(0.08,0.2,20),
            maxnphase=0
        )

        optical_property_generator_small = at3d.medium.OpticalPropertyGenerator(
            'aerosol',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(0.1,2.0,30),
            veff=np.linspace(0.08,0.2,20),
            maxnphase=0
        )

        np.random.seed(1)

        cloud_scatterer = rte_grid.copy(deep=True)
        shape = (rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)
        cloud_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        cloud_scatterer['reff'] = (['x','y','z'], np.random.uniform(10.0,30.0,size=shape))
        cloud_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, cloud_scatterer)

        aerosol_scatterer = rte_grid.copy(deep=True)
        aerosol_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        #r = np.repeat(np.repeat(np.linspace(0.3,0.5, shape[-1])[None,None],shape[0],axis=0),shape[1],axis=1)
        aerosol_scatterer['reff'] = (['x','y','z'], np.random.uniform(0.3,0.5,size=shape))
        aerosol_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        aerosol_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, aerosol_scatterer)

        optical_properties_cloud = optical_property_generator_cloud(cloud_scatterer_on_rte_grid)
        optical_properties_aerosol = optical_property_generator_small(aerosol_scatterer_on_rte_grid)

        cloud = optical_properties_cloud[0.86]
        aerosol = optical_properties_aerosol[0.86]
        cloud['extinction'][:] = np.random.uniform(0.01,10.0,cloud.extinction.shape)
        cloud['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)
        aerosol['extinction'][:] = np.random.uniform(0.01,10.0,aerosol.extinction.shape)
        aerosol['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)

        mixture_exact = at3d.medium.mix_optical_properties(cloud, aerosol, maxnphase=800, asymmetry_tol=0.0, phase_tol=0.0)

        solvers_dict = at3d.containers.SolversDict()

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.0
        config['x_boundary_condition'] = 'periodic'
        config['y_boundary_condition'] = 'periodic'
        config['solution_accuracy'] = 1e-8
        config['num_mu_bins'] = 16
        config['num_phi_bins'] = 32
        config['deltam'] = True
        config['adapt_grid_factor'] = 5.0

        solver1 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'cloud': cloud, 'aerosol': aerosol},
                num_stokes=3
            )
        solver2 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'mixture':mixture_exact},
                num_stokes=3
            )
        solvers_dict.add_solver(1, solver1)
        solvers_dict.add_solver(2, solver2)

        solvers_dict.solve(maxiter=100, verbose=False)

        cls.extinct_exact = solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].extinction.data
        cls.scatter_exact = solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        phase_exact = (solver1.medium['cloud'].phase_weights.data[None,None,...]*solver1.medium['cloud'].legcoef.data[...,solver1.medium['cloud'].table_index-1]*solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data + \
                            solver1.medium['aerosol'].phase_weights.data[None,None,...]*solver1.medium['aerosol'].legcoef.data[...,solver1.medium['aerosol'].table_index-1]*solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data)/(
            solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        )
        cls.phase_exact = phase_exact.sum(axis=2)
        cls.source_exact = solver1._source
        cls.phase_mixture = mixture_exact.legcoef[:,:,:].data.reshape((6,mixture_exact.legendre_index.size)+shape,order='F')
        cls.extinct_mixture = mixture_exact.extinction.data
        cls.scatter_mixture = (mixture_exact.ssalb*mixture_exact.extinction).data
        cls.source_mixture = solver2._source
        mu = np.linspace(0.05,1.0, 361)
        size = mu.size
        sensor_exact = at3d.sensor.make_sensor_dataset(x=[0.5]*size, y=[0.5]*size,z=np.array([1.0]*size),
                                           mu=mu,
                                           phi=np.array([0.0]*size),stokes=['I','Q','U'],fill_ray_variables=True,
                                                   wavelength=0.86)
        sensor_mixture = sensor_exact.copy(deep=True)
        cls.sensor_exact = solver1.integrate_to_sensor(sensor_exact)
        cls.sensor_mixture = solver1.integrate_to_sensor(sensor_mixture)

    def test_extinction(self):
        self.assertTrue(np.allclose(self.extinct_exact, self.extinct_mixture))

    def test_scatter(self):
        self.assertTrue(np.allclose(self.scatter_exact, self.scatter_mixture))

    def test_phase(self):
        print(np.max(np.abs(self.phase_exact-self.phase_mixture)))
        self.assertTrue(np.allclose(self.phase_exact, self.phase_mixture))

    def test_source(self):
        print(np.max(np.abs(self.source_exact-self.source_mixture)))
        self.assertTrue(np.allclose(self.source_exact, self.source_mixture,atol=6e-8))

    def test_intensity(self):
        print(np.max(np.abs(self.sensor_exact.I-self.sensor_mixture.I)))
        self.assertTrue(np.allclose(self.sensor_exact.I, self.sensor_mixture.I))

    def test_Q(self):
        print(np.max(np.abs(self.sensor_exact.Q-self.sensor_mixture.Q)))
        self.assertTrue(np.allclose(self.sensor_exact.Q, self.sensor_mixture.Q))

    def test_U(self):
        print(np.max(np.abs(self.sensor_exact.U-self.sensor_mixture.U)))
        self.assertTrue(np.allclose(self.sensor_exact.U, self.sensor_mixture.U))


class VerifyMultiSpeciesSolverTablePhaseSPATIAL(TestCase):

    @classmethod
    def setUpClass(cls):

        wavelengths = np.array([0.86])#sensor_dict.get_unique_solvers()
        size_distribution_function = at3d.size_distribution.gamma
        mie_mono_tables = OrderedDict()
        for wavelength in wavelengths:
            mie_mono_tables[wavelength] = at3d.mie.get_mono_table(
                'Water',(wavelength,wavelength),
                max_integration_radius=65.0,
                minimum_effective_radius=0.1,
                relative_dir='../mie_tables',
                verbose=False
            )

        rte_grid = at3d.grid.make_grid(0.02, 5, 0.02, 5, np.linspace(0.0, 1.0,11),
        nx=7,ny=7,nz=13)

        optical_property_generator_cloud = at3d.medium.OpticalPropertyGenerator(
            'cloud',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(5.0,30.0,30),
            veff=np.linspace(0.08,0.2,20),
            maxnphase=0
        )

        optical_property_generator_small = at3d.medium.OpticalPropertyGenerator(
            'aerosol',
            mie_mono_tables,
            size_distribution_function,
            reff=np.linspace(0.1,2.0,30),
            veff=np.linspace(0.08,0.2,20),
            maxnphase=0
        )

        np.random.seed(1)

        cloud_scatterer = rte_grid.copy(deep=True)
        shape = (rte_grid.x.size, rte_grid.y.size, rte_grid.z.size)
        cloud_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        cloud_scatterer['reff'] = (['x','y','z'], np.random.uniform(10.0,30.0,size=shape))
        cloud_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        cloud_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, cloud_scatterer)

        aerosol_scatterer = rte_grid.copy(deep=True)
        aerosol_scatterer['density'] = (['x','y','z'], np.ones(shape)*0.01)
        #r = np.repeat(np.repeat(np.linspace(0.3,0.5, shape[-1])[None,None],shape[0],axis=0),shape[1],axis=1)
        aerosol_scatterer['reff'] = (['x','y','z'], np.random.uniform(0.3,0.5,size=shape))
        aerosol_scatterer['veff'] = (['x','y','z'], np.ones(shape)*0.1)
        aerosol_scatterer_on_rte_grid = at3d.grid.resample_onto_grid(rte_grid, aerosol_scatterer)

        optical_properties_cloud = optical_property_generator_cloud(cloud_scatterer_on_rte_grid)
        optical_properties_aerosol = optical_property_generator_small(aerosol_scatterer_on_rte_grid)

        cloud = optical_properties_cloud[0.86]
        aerosol = optical_properties_aerosol[0.86]
        cloud['extinction'][:] = np.random.uniform(0.01,10.0,cloud.extinction.shape)
        cloud['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)
        aerosol['extinction'][:] = np.random.uniform(0.01,10.0,aerosol.extinction.shape)
        aerosol['ssalb'][:] = np.random.uniform(0.0,1.0,cloud.extinction.shape)

        mixture_exact = at3d.medium.mix_optical_properties(cloud, aerosol, maxnphase=800, asymmetry_tol=0.0, phase_tol=0.0)

        solvers_dict = at3d.containers.SolversDict()

        config = at3d.configuration.get_config('../default_config.json')
        config['split_accuracy'] = 0.0
        config['x_boundary_condition'] = 'periodic'
        config['y_boundary_condition'] = 'periodic'
        config['solution_accuracy'] = 1e-8
        config['num_mu_bins'] = 16
        config['num_phi_bins'] = 32
        config['deltam'] = True
        config['adapt_grid_factor'] = 5.0

        solver1 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'cloud': cloud, 'aerosol': aerosol},
                num_stokes=3
            )
        solver2 = at3d.solver.RTE(
                numerical_params=config,
                surface=at3d.surface.lambertian(0.0),
                source=at3d.source.solar(0.86, 0.8,0.0),
                medium={'mixture':mixture_exact},
                num_stokes=3
            )
        solvers_dict.add_solver(1, solver1)
        solvers_dict.add_solver(2, solver2)

        solvers_dict.solve(maxiter=100, verbose=False)

        cls.extinct_exact = solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].extinction.data
        cls.scatter_exact = solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        phase_exact = (solver1.medium['cloud'].phase_weights.data[None,None,...]*solver1.medium['cloud'].legcoef.data[...,solver1.medium['cloud'].table_index-1]*solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data + \
                            solver1.medium['aerosol'].phase_weights.data[None,None,...]*solver1.medium['aerosol'].legcoef.data[...,solver1.medium['aerosol'].table_index-1]*solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data)/(
            solver1.medium['cloud'].ssalb.data*solver1.medium['cloud'].extinction.data +solver1.medium['aerosol'].ssalb.data*solver1.medium['aerosol'].extinction.data
        )
        cls.phase_exact = phase_exact.sum(axis=2)
        cls.source_exact = solver1._source
        cls.phase_mixture = mixture_exact.legcoef[:,:,:].data.reshape((6,mixture_exact.legendre_index.size)+shape,order='F')
        cls.extinct_mixture = mixture_exact.extinction.data
        cls.scatter_mixture = (mixture_exact.ssalb*mixture_exact.extinction).data
        cls.source_mixture = solver2._source
        mu = np.linspace(0.05,1.0, 361)
        size = mu.size
        sensor_exact = at3d.sensor.make_sensor_dataset(x=[0.5]*size, y=[0.5]*size,z=np.array([1.0]*size),
                                           mu=mu,
                                           phi=np.array([0.0]*size),stokes=['I','Q','U'],fill_ray_variables=True,
                                                   wavelength=0.86)
        sensor_mixture = sensor_exact.copy(deep=True)
        cls.sensor_exact = solver1.integrate_to_sensor(sensor_exact)
        cls.sensor_mixture = solver1.integrate_to_sensor(sensor_mixture)

    def test_extinction(self):
        self.assertTrue(np.allclose(self.extinct_exact, self.extinct_mixture))

    def test_scatter(self):
        self.assertTrue(np.allclose(self.scatter_exact, self.scatter_mixture))

    def test_phase(self):
        print(np.max(np.abs(self.phase_exact-self.phase_mixture)))
        self.assertTrue(np.allclose(self.phase_exact, self.phase_mixture))

    def test_source(self):
        print(np.max(np.abs(self.source_exact-self.source_mixture)))
        self.assertTrue(np.allclose(self.source_exact, self.source_mixture,atol=6e-8))

    def test_intensity(self):
        print(np.max(np.abs(self.sensor_exact.I-self.sensor_mixture.I)))
        self.assertTrue(np.allclose(self.sensor_exact.I, self.sensor_mixture.I))

    def test_Q(self):
        print(np.max(np.abs(self.sensor_exact.Q-self.sensor_mixture.Q)))
        self.assertTrue(np.allclose(self.sensor_exact.Q, self.sensor_mixture.Q))

    def test_U(self):
        print(np.max(np.abs(self.sensor_exact.U-self.sensor_mixture.U)))
        self.assertTrue(np.allclose(self.sensor_exact.U, self.sensor_mixture.U))
